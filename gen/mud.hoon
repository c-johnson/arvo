::  Compile arvo as a pill noun, for compiler changes; 
::  usage 
::
::    .urbit/pill +mud
::
::::  /hoon/mud/gen
  ::
/?    310
::
::::
  !:
:-  %say
|=  $:  {now/@da eny/@uvJ bec/beak}
        {$~ $~}
    ==
:-  %noun
=+  ^=  must
    ::  virtualize, running in a nested memory ring
    ::  
    |*  taq/_|.(**)
    =+  muz=(mule taq)
    ?-  -.muz
      $&  p.muz
      $|  (mean p.muz)
    ==
=+  top=`path`/(scot %p p.bec)/[q.bec]/(scot %da now)/sys
=+  pax=`path`(weld top `path`[%hoon ~])
=+  arp=`path`(weld top `path`[%ovra ~])
~&  %mud-start
=+  txt=.^(@t %cx (weld pax `path`[%hoon ~]))
=+  rax=.^(@t %cx (weld arp `path`[%hoon ~]))
~&  %mud-loaded
=+  gen=(must |.((rain pax txt)))
~&  %mud-parsed
=+  one=(must |.((~(mint ut %noun) %noun gen)))
~&  %mud-compiled
=+  gat=`vase`[p.one .*(0 q.one)]
~&  %mud-done-hoon
=+  kyr=`(pair vase vase)`[(slap ked [%limb %p]) (slap ked [%limb %q])]
~&  %mud-next-arvo
=+  
    %-  must  |.
    (slam gat (slop p.kyr `vase`[[%atom %t ~] rax]))
~&  %mud-done-arvo
=+  ayr=`(pair vase vase)`[(slap arv [%limb %p]) (slap arv [%limb %q])]
=+  ken=[7 q.q.kyr q.q.ayr]
~&  [%mud-recompiled `@ux`(mug ken)]
:-  ken
=+  all=.*(0 ken)
=+  ^=  vay  ^-  (list {p/@tas q/path})
    :~  [%$ /zuse]
        [%f /vane/ford]
        [%c /vane/clay]
        [%g /vane/gall]
        [%a /vane/ames]
        [%b /vane/behn]
        [%d /vane/dill]
        [%e /vane/eyre]
    ==
|-  ^+  all
?~  vay  all
=+  pax=(weld top q.i.vay)
=+  txt=.^(@ %cx (weld pax `path`[%hoon ~]))
=+  sam=[now `ovum`[[%gold ~] [%veer p.i.vay pax txt]]]
~&  [%solid-veer i.vay]
=+  gat=.*(all .*(all [0 42]))
=+  nex=+:.*([-.gat [sam +>.gat]] -.gat)
$(vay t.vay, all nex)

